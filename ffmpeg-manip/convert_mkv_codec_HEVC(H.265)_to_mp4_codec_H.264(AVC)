âœ… Commande de base (conversion rapide sans rÃ©-encodage) :
ffmpeg -i IP17.mkv -c copy IP17s.mp4
-i input.mkv : le fichier source.

-c copy : copie les pistes vidÃ©o et audio sans rÃ©-encodage (rapide, sans perte de qualitÃ©).

output.mp4 : le fichier de sortie.

ğŸ”¸ Limite : cette mÃ©thode ne marche que si les codecs de la vidÃ©o et de lâ€™audio sont compatibles avec le conteneur MP4 (ex. H.264 pour la vidÃ©o, AAC pour lâ€™audio).

âœ… DÃ©tail :
libx264 = encodeur logiciel universel pour H.264.
Fonctionne sur tous les processeurs : Intel, AMD, ARM, etc.
Utilise le CPU (pas le GPU).


       ğŸ”´CAS A:libx264() Universel)
ğŸš€ Si tu veux la commande la plus rapide possible pour rÃ©encoder en H.264 :

ffmpeg -i IP17.mkv -c:v libx264 -preset ultrafast -crf 23 -c:a copy IP17s.mp4

 ğŸŸ£-c:v libx264 â†’ rÃ©encode la vidÃ©o en H.264 (au lieu de HEVC).

 ğŸŸ£-crf 23 â†’ qualitÃ© constante. Plus petit = meilleure qualitÃ© (valeurs typiques : 18â€“28).
reste un bon Ã©quilibre (tu peux ajuster : plus bas = meilleure qualitÃ©, plus haut = plus rapide).

 ğŸŸ£-preset ultrafast â†’ vitesse maximale, taille de fichier plus grande et qualitÃ© lÃ©gÃ¨rement infÃ©rieure Ã  bitrate Ã©quivalent.

 ğŸŸ£-c:a copy â†’ copie l'audio sans le rÃ©encoder (pour Ã©viter perte de qualitÃ©).


ğŸ†š RÃ©sumÃ© :
Commande	              Vitesse	             QualitÃ©	     Fichier
-preset ultrafast	      ğŸš€ TrÃ¨s rapide	    ğŸ˜ Moyenne	   ğŸ“¦ Grand
-preset fast ou medium	  âš–ï¸ Moyen	            ğŸ˜Š Bonne	   ğŸ“¦ Moyen
-preset slow ou slower	  ğŸ¢ Lent	            ğŸ˜ Excellente  ğŸ“¦ Petit
-preset slow = Ã©quilibre 
   entre vitesse d'encodage et 
   efficacitÃ© de compression 
   (tu peux mettre medium ou faster si tu es pressÃ©).


ğŸ“ Si tu veux rÃ©encoder aussi lâ€™audio (pour compatibilitÃ© maximale) :
ffmpeg -i IP17.mkv -c:v libx264 -crf 23 -preset slow -c:a aac -b:a 192k IP17s.mp4




ğŸ”´ Si tu veux une version optimisÃ©e pour Intel GPU (Quick Sync Video) :
ğŸ” Pour vÃ©rifier si FFmpeg supporte QSV :
Dans le terminal :

Linux:
ffmpeg -encoders | grep qsv

Windows PowerShell:
ffmpeg -encoders | Select-String qsv

Tu devrais voir des lignes comme :

css
 V..... h264_qsv           Intel Quick Sync Video H.264 encoder (codec h264)
 V..... hevc_qsv           Intel Quick Sync Video HEVC encoder (codec hevc)
Si tu ne les vois pas, tu dois :

installer FFmpeg compilÃ© avec QSV support (souvent le cas dans les versions rÃ©centes)

ou compiler FFmpeg toi-mÃªme avec les bons flags





GPU : Intel HD Graphics 520 â†’ supporte Quick Sync Video (QSV)
CPU : Intel Core i5 (probablement de 6e gÃ©nÃ©ration, Skylake) â†’ compatible avec Intel Quick Sync

âœ… FFmpeg + Intel Quick Sync (QSV)
FFmpeg peut utiliser Quick Sync Video pour encoder/dÃ©coder plus rapidement (moins de charge CPU).




ğŸ”§ Commande pour encoder en H.264 avec QSV :
 ğŸŸ  Tu peux utiliser lâ€™encodeur matÃ©riel Intel :

   ğŸ”µ1. Avec rÃ©-encodage audio (ex : -c:a aac)
     ffmpeg -i IP17.mkv -c:v h264_qsv -preset veryfast -c:a aac output.mp4
        VidÃ©o : encodÃ©e matÃ©riellement via QuickSync â†’ rapide.
        Audio : rÃ©-encodÃ© en AAC â†’ dÃ©pend du CPU, ajoute du temps.
        Peut aussi perdre un peu en qualitÃ© selon les paramÃ¨tres.
        Vitesse globale : bonne, mais lâ€™audio ralentit un peu le processus.

    ğŸ”µ2. Sans rÃ©-encodage audio (copie directe)
        
      VidÃ©o : encodÃ©e matÃ©riellement via QuickSync â†’ trÃ¨s rapide.
      Audio : copiÃ© sans rÃ©-encodage â†’ pas de perte de qualitÃ©, gain de temps.
      Vitesse globale : encore meilleure.
      Moins de charge CPU, pas de perte de qualitÃ©.

        ğŸŸ£A/ffmpeg -i IP17.mkv -c:v h264_qsv -preset veryfast -c:a copy IP17s1.mp4

           DÃ©codage logiciel (par dÃ©faut) : FFmpeg utilise le dÃ©codage logiciel du flux HEVC.

           Encodage matÃ©riel (QSV) : Tu rÃ©encode en H.264 avec Intel Quick Sync Video (h264_qsv).

           Pas de bitrate fixÃ© : FFmpeg utilise l'encodage en mode CQP (quantitÃ© fixe de qualitÃ©) par dÃ©faut (pas de contrÃ´le sur le poids final).

           Audio copiÃ© sans modification.

           Preset veryfast : prioritÃ© Ã  la vitesse, moins de compression.

          âœ… Avantages :
             Simple et rapide si tu nâ€™as pas besoin dâ€™un bitrate fixe.

             Peut Ãªtre plus compatible avec une machine oÃ¹ le dÃ©codage matÃ©riel HEVC ne marche pas bien.

        ğŸŸ£B/
          ğŸ”´B1/ffmpeg -c:v hevc_qsv -i IP17.mkv  -c:v h264_qsv -preset veryfast -b:v 4M -c:a copy IP17s2.mp4 

            MatÃ©riel utilisÃ©= GPU (hevc_qsv)
            DÃ©codage matÃ©riel HEVC avec Quick Sync Video (hevc_qsv) â†’ plus rapide et Ã©conomique en CPU.

             Encodage matÃ©riel H.264 QSV, bitrate fixÃ© Ã  4 Mbps.

             Audio copiÃ©.

             Preset veryfast : comme avant.
          âœ… Avantages :
            Plus rapide si ton GPU Intel supporte bien hevc_qsv.

            Le bitrate fixe de 4M te donne un contrÃ´le sur la taille finale.

            IdÃ©al pour garder un dÃ©bit raisonnable (pour YouTube, stockage, etc.).

        Conclusion: B1 est plus rapide meme sans controle de qualitÃ©(bitrate) car travaille sur gpu
         et A travaille sur cpu

         ğŸ”´B2/On ajoute --vf format=nv12
          ffmpeg -c:v hevc_qsv -i IP17.mkv -vf format=nv12 -c:v h264_qsv -preset veryfast -b:v 4M -c:a copy IP17s2.mp4
            
            La diffÃ©rence ici est qu'on forces manuellement le format vidÃ©o Ã  nv12, 
            qui est le format prÃ©fÃ©rÃ© du QSV encoder (h264_qsv).
            Cela garantit la compatibilitÃ© entre le filtre de dÃ©codage QSV et l'encodage H.264 QSV.
          
          ğŸ”´Comparaison entre B1 et ğŸ”´B2
            
                                            Sans -vf format=nv12 	                Avec -vf format=nv12
Format de pixel              	               Automatique (FFmpeg dÃ©cide)	           ForcÃ© Ã  nv12
SÃ©curitÃ© / compatibilitÃ© QSV	               Moins garanti	                         Plus robuste
StabilitÃ© entre diffÃ©rentes                  Peut Ã©chouer sur certains systÃ¨mes      Presque toujours fonctionne
machines/pilotes	                   	
Vitesse / performance	                      Pareil (Ã  99 %)	                          Peut avoir un tout petit overhead

    B2 est lÃ©gÃ©rement plus rapide(diff trÃ©s minime secondes ou max min) et plus stable, car il force le format vidÃ©o Ã  nv12,

    âš ï¸ Attention : compatibilitÃ© audio
        VÃ©rifie que la piste audio de dÃ©part est en AAC ou un codec MP4-compatible (ex : MP3, AAC, ALACâ€¦).

       Si lâ€™audio est en EAC3 ou DTS, MP4 ne supporte pas toujours directement â†’ -c:a copy peut Ã©chouer ou 
       rendre le fichier non lisible.

       Pour les vidÃ©os venant de MKV avec audio en EAC3 : mieux vaut encoder en AAC, sauf si tu veux sortir en MKV aussi.

  ğŸ”µ Formats audio compatibles avec MP4 (standards ou largement supportÃ©s)
      Codec     	Extension    	DÃ©tails
       AAC	        .aac	      Le plus courant et recommandÃ©. Support universel.
       MP3	        .mp3	      SupportÃ© par la majoritÃ© des lecteurs MP4.
       ALAC	        .m4a	      Format Apple Lossless, pris en charge dans MP4 (surtout Apple devices).
       AC-3*	      .ac3	      Parfois acceptÃ© (ex : VLC), mais pas officiellement supportÃ© dans MP4.
       Opus*	      .opus	       Support expÃ©rimental dans MP4, pas garanti sur tous les lecteurs.
 
   âŒ Formats audio Ã  Ã©viter dans MP4
     Codec	       Pourquoi Ã©viter ?
      EAC3	         Rarement pris en charge dans MP4. Mieux dans MKV.
      DTS	           Non supportÃ© dans MP4. Cause souvent des erreurs de lecture ou de muxing.
      FLAC        	 Non standard dans MP4 (prÃ©fÃ©rÃ© dans MKV).
      Vorbis      	 Pas compatible avec MP4.

  ğŸŸ Si tu veux utiliser lâ€™accÃ©lÃ©ration matÃ©rielle pour le dÃ©codage et lâ€™encodage, voici la commande complÃ¨te
   ffmpeg -hwaccel qsv -i IP17.mkv -c:v h264_qsv -preset veryfast -c:a aac output.mp4   
    
   ffmpeg -hwaccel qsv -c:v hevc_qsv -i IP17.mkv -c:v h264_qsv -preset veryfast -b:v 4M -c:a copy IP17P.mp4

 
Si tu as l''erreur:
 [h264_qsv @ ...] Current pixel format is unsupported
[vost#0:0/h264_qsv @ ...] Error while opening encoder - maybe incorrect parameters such as bit_rate, rate, 
 width or height.

Cela indique que le format de pixel 10 bits (yuv420p10le)car câ€™est un HEVC 10 bits. utilisÃ© par la vidÃ©o 
d''entrÃ©e n''est pas compatible avec le codec Intel QSV H.264, qui n''accepte que du 8 bits (comme yuv420p).


ce genre dâ€™erreur est classique quand tu combines -hwaccel qsv et -c:v h264_qsv sans gÃ©rer correctement la
 dÃ©codage matÃ©riel et la conversion des formats pixel.

Pourquoi ta commande avec -hwaccel qsv plante ?
-hwaccel qsv active lâ€™accÃ©lÃ©ration matÃ©rielle Intel QuickSync au dÃ©codage.

Par contre, le dÃ©codeur renvoie des images dans un format matÃ©riel (ex: nv12 en mÃ©moire vidÃ©o).

Lâ€™encodeur h264_qsv attend une image dans un format spÃ©cifique, souvent en mÃ©moire accessible CPU ou bien
compatible.

Si tu ne convertis pas ce format, FFmpeg se plaint de Current pixel format is unsupported ou Function 
not implemented.




âœ… Solution : Forcer une conversion en 8 bits (yuv420p)
   ğŸŸ¡ sans hwaccel
ffmpeg -c:v hevc_qsv -i IP17.mkv -vf format=nv12 -c:v h264_qsv -preset veryfast -b:v 4M -c:a copy IP17s1.mp4 
ffmpeg -init_hw_device qsv=hw -filter_hw_device hw -c:v hevc_qsv -i IP17.mkv -vf format=nv12,hwupload -c:v h264_qsv -b:v 4M -c:a copy IP17s.mp4 


 ğŸŸ£ -init_hw_device qsv=hw
    initialise un pÃ©riphÃ©rique matÃ©riel de type qsv (Quick Sync Video dâ€™Intel).
    qsv=hw : on crÃ©e un alias appelÃ© hw que lâ€™on pourra rÃ©utiliser ensuite.
    âš™ï¸ Cela prÃ©pare le GPU Intel pour quâ€™il puisse Ãªtre utilisÃ© par le reste de la commande.

  ğŸŸ£ -filter_hw_device hw
      indique que tous les filtres vidÃ©o matÃ©riels (comme hwupload, scale_qsv, etc.) utiliseront le
      pÃ©riphÃ©rique hw que tu viens d'initialiser.

     âš ï¸ Obligatoire si tu utilises hwupload ou un filtre qui traite des frames en mÃ©moire GPU.

        FFmpeg, quand tu lui demandes dâ€™utiliser hwupload, doit savoir vers quel pÃ©riphÃ©rique graphique
         (GPU Intel) envoyer les images Ã  encoder avec h264_qsv.
        Mais par dÃ©faut, il ne sait pas quel pÃ©riphÃ©rique utiliser, surtout si :
        Tu ne prÃ©cises pas -init_hw_device qsv=hw.
        Tu fais un traitement avec des filtres (comme -vf format=nv12,hwupload) avant de lui dire quel
         matÃ©riel utiliser.
 
 ğŸŸ£ h264_qsv n''accepte pas nativement le 10 bits, il attend du NV12 8 bits.

 ğŸŸ£Lâ€™erreur peut survenir si hwaccel qsv est activÃ© et que le dÃ©codage matÃ©riel nâ€™est pas en QSV, ou bien que le dÃ©codage QSV produit un format incompatible.

 ğŸŸ£-c:v hevc_qsv	Force FFmpeg Ã  utiliser le dÃ©codage matÃ©riel Intel Quick Sync Video (QSV) pour le codec HEVC (H.265). Cela accÃ©lÃ¨re le dÃ©codage.

 ğŸŸ£-i IP17.mkv	SpÃ©cifie le fichier dâ€™entrÃ©e vidÃ©o, ici IP17.mkv.

 ğŸŸ£-Le filtre format=nv12,hwupload doit faire la conversion vers NV12 8 bits puis remonter sur le GPU.
   vf format=nv12,hwupload	Applique une chaÃ®ne de filtres vidÃ©o (-vf = video filter) :
    - format=nv12 convertit la vidÃ©o en format NV12 8 bits, compatible avec QSV.
    - hwupload tÃ©lÃ©charge (upload) la vidÃ©o convertie sur le GPU pour lâ€™encodage matÃ©riel.

    NB:Lâ€™ajout de hwupload est utile seulement si tu rencontres :

          des erreurs comme unsupported pixel format,

          ou des encodages trÃ¨s lents malgrÃ© qsv.

 ğŸŸ£-c:v h264_qsv	Utilise lâ€™encodeur matÃ©riel Intel QSV pour encoder la vidÃ©o en H.264 (AVC).

 ğŸŸ£-b:v 4M	DÃ©finit le dÃ©bit vidÃ©o (bitrate) Ã  4 mÃ©gabits par seconde. Tu peux ajuster ce chiffre pour plus ou moins de qualitÃ©.

 ğŸŸ£-c:a copy	Copie le flux audio sans le rÃ©encoder (gain de temps et prÃ©servation de la qualitÃ© audio).

 ğŸŸ£IP17s.mp4	Nom du fichier de sortie final, ici un MP4 contenant la vidÃ©o H.264 encodÃ©e avec QSV.
  

 
ğŸŸ¡ Avec hwaccel(accÃ©lÃ©ration matÃ©rielle)
 ffmpeg -init_hw_device qsv=hw -filter_hw_device hw -c:v hevc_qsv -i IP17.mkv -vf "format=nv12,hwupload" -c:v h264_qsv -preset veryfast -b:v 4M -c:a copy IP17_fixed.mp4 




   ğŸŸ¢ Pourquoi cette commande ?
 DÃ©codage accÃ©lÃ©rÃ© QSV (-c:v hevc_qsv) : Permet de dÃ©coder rapidement les vidÃ©os HEVC 10 bits sur CPU Intel avec support QSV.

Conversion en NV12 8 bits (format=nv12) :
 Le dÃ©codage QSV produit du 10 bits, mais lâ€™encodeur H264 QSV ne supporte que le 8 bits. Il faut donc 
 convertir la vidÃ©o dans un format compatible (NV12 = YUV 4:2:0 8 bits).

 Upload matÃ©riel (hwupload) : AprÃ¨s conversion, la vidÃ©o est envoyÃ©e sur le GPU Intel pour que lâ€™encodeur
  QSV puisse y accÃ©der.

 Encodage matÃ©riel H264 QSV (-c:v h264_qsv) : Encodage rapide en H.264 grÃ¢ce au matÃ©riel Intel.

 Copie audio (-c:a copy) : Pour ne pas perdre de temps Ã  rÃ©encoder le son, il est simplement copiÃ© tel quel.

 Bitrate dÃ©fini (-b:v 4M) : Fixe la qualitÃ© vidÃ©o pour un bon compromis vitesse/qualitÃ©.


RÃ©sumÃ©
 Cette commande est optimisÃ©e pour un PC Intel avec Quick Sync. Elle dÃ©code le HEVC 10 bits avec accÃ©lÃ©ration matÃ©rielle, convertit la vidÃ©o dans un format compatible 8 bits, puis encode en H264 8 bits avec accÃ©lÃ©ration matÃ©rielle, tout en copiant lâ€™audio dâ€™origine.

ğŸŸ¡Pour une commande plus rapide: ajouter -preset veryfast

 Measure-Command { ffmpeg -init_hw_device qsv=hw -filter_hw_device hw -c:v hevc_qsv -i IP17.mkv -vf format=nv12,hwupload -c:v h264_qsv -preset veryfast -b:v 4M -c:a copy IP17s.mp4 }






Lâ€™option -look_ahead active ou dÃ©sactive la fonction de "look-ahead" du QSV encoder (Quick Sync Video) dâ€™Intel.
Cela permet au codeur de regarder plusieurs images Ã  l'avance pour optimiser la qualitÃ© d'encodage ou le dÃ©bit binaire.

âœ… Avec -look_ahead 1 (activÃ©)
 Le codeur regarde les images futures avant de dÃ©cider comment encoder la frame actuelle.

 Meilleure qualitÃ© visuelle Ã  dÃ©bit identique, surtout sur les mouvements complexes ou rapides.

 Potentiellement meilleure compression.

 Peut augmenter la latence (important si vous streamez en direct).

 Utilise plus de ressources CPU/GPU.

âŒ Avec -look_ahead 0 (dÃ©sactivÃ©)   
 Le codeur encode image par image, sans prÃ©-analyse.

 RÃ©sultats plus rapides, latence minimale.

 QualitÃ© potentiellement infÃ©rieure Ã  dÃ©bit Ã©gal.

 Moins de consommation de ressources.


NB
Par dÃ©faut, -look_ahead est souvent dÃ©sactivÃ© (0) si tu utilises :

-preset veryfast

un mode CBR ou VBR classique

Mais si tu actives certains autres paramÃ¨tres comme :

 -rc_mode la (look-ahead rate control) ou -preset slow

Alors FFmpeg peut activer automatiquement look_ahead=1, sauf si tu le forces Ã  0.


âœ… Donc, pour Ãªtre sÃ»r :
Si tu veux dÃ©sactiver explicitement la prÃ©-analyse âœ mets -look_ahead 0

Si tu veux en profiter pour optimiser la qualitÃ© âœ mets -look_ahead 1

Si tu ne mets rien, le comportement peut varier selon le contexte, donc pas 100 % prÃ©visible.

ğŸŸ§ Pour sÃ©lectionner un sous-titre parmi ceux prÃ©sents dans ta vidÃ©o HEVC .mkv, et le graver en "hardsub"
 (sous-titres incrustÃ©s dans la vidÃ©o) lors de la conversion en H.264, voici comment faire avec ffmpeg.

âœ… 
ğŸ” 1. VÃ©rifie les sous-titres prÃ©sents
Lance cette commande pour voir les pistes (streams) dans ton fichier IP17.mkv :
  ffmpeg -i IP17.mkv

Tu verras une sortie comme ceci :
  Stream #0:0: Video: hevc
  Stream #0:1: Audio: ...
  Stream #0:2: Subtitle: ass (default)
  Stream #0:3: Subtitle: srt
  Stream #0:4: Subtitle: ass

Note bien le numÃ©ro du flux de sous-titres que tu veux incruster 


La commande sur mon ordi me donne
Par exemple
 Stream #0:0(jpn): Video: hevc (Main 10), yuv420p10le(tv), 1920x1080, SAR 1:1 DAR 16:9, 23.98 fps, 23.98 tbr, 1k tbn (default)
      Metadata:
        title           : [Erai-raws]_CR_HEVC
        BPS             : 3336693
        DURATION        : 00:24:17.748000000
        NUMBER_OF_FRAMES: 34951
        NUMBER_OF_BYTES : 608007301
        _STATISTICS_WRITING_APP: mkvmerge v92.0 ('Everglow') 64-bit
        _STATISTICS_WRITING_DATE_UTC: 2025-06-01 13:51:40
        _STATISTICS_TAGS: BPS DURATION NUMBER_OF_FRAMES NUMBER_OF_BYTES
  Stream #0:1(jpn): Audio: eac3, 48000 Hz, stereo, fltp, 224 kb/s (default)
      Metadata:
        title           : AMZN_EAC3
        BPS             : 224000
        DURATION        : 00:24:17.696000000
        NUMBER_OF_FRAMES: 45553
        NUMBER_OF_BYTES : 40815488
        _STATISTICS_WRITING_APP: mkvmerge v92.0 ('Everglow') 64-bit
        _STATISTICS_WRITING_DATE_UTC: 2025-06-01 13:51:40
        _STATISTICS_TAGS: BPS DURATION NUMBER_OF_FRAMES NUMBER_OF_BYTES
  Stream #0:2(eng): Subtitle: ass (ssa) (default)
      Metadata:
        title           : CR_English
        BPS             : 129
        DURATION        : 00:24:02.520000000
        NUMBER_OF_FRAMES: 384
        NUMBER_OF_BYTES : 23397
        _STATISTICS_WRITING_APP: mkvmerge v92.0 ('Everglow') 64-bit
        _STATISTICS_WRITING_DATE_UTC: 2025-06-01 13:51:40
        _STATISTICS_TAGS: BPS DURATION NUMBER_OF_FRAMES NUMBER_OF_BYTES
  Stream #0:3(por): Subtitle: ass (ssa)
      Metadata:
        title           : CR_Portuguese(Brazil)
        BPS             : 167
        DURATION        : 00:24:06.510000000
        NUMBER_OF_FRAMES: 391
        NUMBER_OF_BYTES : 30280
        _STATISTICS_WRITING_APP: mkvmerge v92.0 ('Everglow') 64-bit
        _STATISTICS_WRITING_DATE_UTC: 2025-06-01 13:51:40
        _STATISTICS_TAGS: BPS DURATION NUMBER_OF_FRAMES NUMBER_OF_BYTES
  Stream #0:4(spa): Subtitle: ass (ssa)
      Metadata:
        title           : CR_Spanish(Latin_America)
        BPS             : 118
        DURATION        : 00:24:02.630000000
        NUMBER_OF_FRAMES: 329
        NUMBER_OF_BYTES : 21408
        _STATISTICS_WRITING_APP: mkvmerge v92.0 ('Everglow') 64-bit
        _STATISTICS_WRITING_DATE_UTC: 2025-06-01 13:51:40
        _STATISTICS_TAGS: BPS DURATION NUMBER_OF_FRAMES NUMBER_OF_BYTES


Si tu veux incrustr celui d'eng(Stream #0:2) sur la video
Tableau sous titre s=[eng,por,spa]
donc l'anglais est si=0


ğŸ”¨ 2. Commande pour graver un sous-titre (hardsub)
Tu ne peux graver quâ€™un seul sous-titre Ã  la fois, et il faut que ce soit en format texte lisible 
(.ass, .srt), pas des sous-titres bitmap (.pgs, .dvd_subtitle).

Exemple avec le sous-titre en piste 0:2 :

         âœ…Version avec libx264
ffmpeg -i IP17.mkv -vf "subtitles=IP17.mkv:si=0" -c:v libx264 -preset fast -b:v 4M -c:a copy IP17_hardsub.mp4


ğŸŸ¡ Remplace si=...par le bon index si le sous-titre Ã  incruster est sur une autre piste

        âœ… Version avec Intel QSV (h264_qsv) :
ffmpeg -i IP17.mkv -map 0:v -map 0:a -c:v h264_qsv -c:a aac -vf "subtitles=IP17.mkv:si=2" IP17_hardsub.mp4

  -vf "subtitles=tonfichier.mkv:si=2" : incruste le sous-titre piste 2 du MKV.

  -c:v h264_qsv : encode en H.264 matÃ©riel (tu peux changer en libx264 si pas QSV).

  -c:a aac : encode lâ€™audio en AAC.

  -map 0:v et -map 0:a : rÃ©cupÃ¨re vidÃ©o et audio.

Plus rapide :utiliser vveryfast
  Measure-Command {ffmpeg -i IP17.mkv -map 0:v -map 0:a -c:v h264_qsv -preset veryfast -c:a aac -vf "subtitles=IP17.mkv:si=0" IP17eng.mp4}






âŒ› Pour afficher le temps total pris par ta commande ffmpeg Ã  la fin de son exÃ©cution, voici plusieurs mÃ©thodes simples :

ğŸŸ¢ Sur Windows cmd.exe (PowerShell) : utiliser Measure-Command
   
Si tu es sous PowerShell, lance ta commande ainsi :
Measure-Command { ffmpeg -init_hw_device qsv=hw -filter_hw_device hw -c:v hevc_qsv -i IP17.mkv -vf format=nv12,hwupload -c:v h264_qsv -b:v 4M -c:a copy IP17s.mp4 }


RÃ©sultat:
Days              : 0
Hours             : 0
Minutes           : 12
Seconds           : 52
Milliseconds      : 382
Ticks             : 7723820642
TotalDays         : 0,00893960722453704
TotalHours        : 0,214550573388889
TotalMinutes      : 12,8730344033333
TotalSeconds      : 772,3820642
TotalMilliseconds : 772382,0642


Sans filtre : 
 FFmpeg gÃ¨re automatiquement les formats, Ã§a peut prendre plus de temps si la conversion est complexe.
 ffmpeg -c:v hevc_qsv -i IP17.mkv -c:v h264_qsv -b:v 4M -c:a copy IP17p.mp4

Avec filtre: 
 format=nv12: tu forces un format optimal, donc gain de performance avec QSV.
              sert Ã  forcer la conversion de la vidÃ©o en format NV12
              (un format de pixel YUV 4:2:0 trÃ¨s courant et optimisÃ© pour les encodeurs matÃ©riels comme QSV).

 NV12 est souvent la seule ou la meilleure format d''entrÃ©e que le codec Quick Sync (Intel QSV) accepte pour lâ€™encodage.

En gros, Ã§a prÃ©pare la vidÃ©o dans un format que QSV adore, souvent nÃ©cessaire si la vidÃ©o source est dans un format Â« exotique Â» ou pas compatible directement.

En forÃ§ant format=nv12, tu donnes directement Ã  lâ€™encodeur la bonne entrÃ©e, donc la conversion est plus optimisÃ©e, moins dâ€™Ã©tapes, moins de latence.



ğŸŸ¡Presets disponibles pour h264_qsv :
 | Preset         | QualitÃ© ğŸ“ˆ | Vitesse ğŸ“‰ |
| -------------- | ----------  | ----------  |
| `veryslow`     | â­â­â­â­  | ğŸ¢ğŸ¢ğŸ¢ğŸ¢  |
| `slower`       | â­â­â­â­  | ğŸ¢ğŸ¢ğŸ¢     |
| `slow`         | â­â­â­     | ğŸ¢ğŸ¢       |
| `medium` (def) | â­â­       | ğŸ¢          |
| `fast`         | â­         | ğŸš¶â€â™‚ï¸           |
| `faster`       | â­         | ğŸƒâ€â™‚ï¸          |
| `veryfast`     | â­         | ğŸš€          |



 ğŸ”´Remarque
   **-c:v hevc_qsv -i input.mkv** â†’ tu dÃ©codes une vidÃ©o encodÃ©e en HEVC Ã  lâ€™aide du dÃ©codage matÃ©riel QSV.

   **-c:v h264_qsv** â†’ tu rÃ©-encodes la vidÃ©o en H.264 avec lâ€™encodeur matÃ©riel QSV.

   Tu spÃ©cifies aussi -preset veryfast, mais comme expliquÃ©, ce preset a un impact faible sur la qualitÃ©/taille finale avec h264_qsv si tu imposes dÃ©jÃ  un bitrate fixe (-b:v 4M).

   Avec -b:v 4M, tu forces le dÃ©bit vidÃ©o Ã  4 Mbps â†’ donc la taille finale reste proche quel que soit le preset.



ğŸŸ¢Sur  Linux/macOS ou Windows avec Git Bash
 Utiliser la commande time 
 time ffmpeg -c:v hevc_qsv -i IP17.mkv -vf format=nv12 -c:v h264_qsv -b:v 4M -c:a copy IP17s.mp4

Ã€ la fin, tu verras un rÃ©sumÃ© comme :
 real    0m35.123s
 user    0m30.456s
 sys     0m4.567s
 real = temps Ã©coulÃ© total (temps Â« rÃ©el Â»)

user = temps CPU utilisateur

sys = temps CPU noyau





ğŸŸ§ Pour NVIDIA (GPU avec NVENC) :
ffmpeg -hwaccel cuda -i IP17.mkv -c:v h264_nvenc -preset fast -cq 23 -c:a copy IP17s.mp4
âœ… Explication :
-hwaccel cuda : utilise lâ€™accÃ©lÃ©ration GPU NVIDIA.

-c:v h264_nvenc : encodeur matÃ©riel H.264 de NVIDIA.

-preset fast : vitesse dâ€™encodage.

-cq 23 : qualitÃ© constante (23 = qualitÃ© moyenne, baisse = mieux).

-c:a copy : conserve lâ€™audio sans le rÃ©encoder.

ğŸ”¹ TrÃ¨s rapide, parfait pour une conversion simple sans perte notable.



ğŸŸ§ Pour AMD (GPU avec AMF / VCE) :


ffmpeg -hwaccel dxva2 -i IP17.mkv -c:v h264_amf -quality speed -c:a copy IP17s.mp4
âœ… Explication :
-hwaccel dxva2 : active lâ€™accÃ©lÃ©ration sur Windows pour AMD.

-c:v h264_amf : encodeur matÃ©riel AMD (AMF = Advanced Media Framework).

-quality speed : privilÃ©gie la rapiditÃ©.

-c:a copy : copie lâ€™audio tel quel.

ğŸ”¸ Rapide aussi, mais plus dÃ©pendant du support de ton driver AMD. Assure-toi dâ€™avoir les pilotes GPU Ã  jour.


NB
Pour les cartes graphiques AMD, les meilleurs accÃ©lÃ©rateurs matÃ©riels (hwaccel) sont :

ğŸ”¥ 1. h264_amf (AMD Advanced Media Framework)
Le plus performant pour l'encodage H.264 et H.265 sur AMD.

Utilise l'API AMF d'AMD, spÃ©cialement optimisÃ©e pour les cartes graphiques Radeon.

Compatible avec les cartes AMD rÃ©centes (RX 400 et plus rÃ©centes).

Fonctionne particuliÃ¨rement bien sur Windows.

ğŸ”¥ 2. d3d11va (Direct3D 11 Video Acceleration)
TrÃ¨s bon pour le dÃ©codage matÃ©riel de vidÃ©os H.264, H.265, VP9, etc.

Compatible avec les cartes AMD modernes sur Windows.

SupportÃ© par FFmpeg pour l'encodage et le dÃ©codage.

GÃ©nÃ©ralement utilisÃ© pour la dÃ©codage et non pour l'encodage.

ğŸ”¥ 3. vaapi (Video Acceleration API)
Fonctionne sur Linux principalement.

Supporte l'encodage et le dÃ©codage H.264, H.265, VP9, etc.

Peut fonctionner avec des cartes AMD, mais mieux adaptÃ© aux processeurs graphiques intÃ©grÃ©s d'Intel.

âœ… Meilleur choix pour toi :
Puisque tu es sous Windows avec une carte AMD, le meilleur choix pour l'encodage est : -hwaccel h264_amf
Pour le dÃ©codage, tu peux utiliser :-hwaccel d3d11va


ğŸ” RÃ©sumÃ© rapide :
Marque GPU	Commande optimisÃ©e
NVIDIA	-c:v h264_nvenc + -hwaccel cuda
AMD	-c:v h264_amf + -hwaccel dxva2

Tu peux tester la vitesse avec -benchmark Ã  la fin de ta commande si tu veux comparer.




ğŸ¯ Astuce bonus : Script pour convertir tous les .mkv dâ€™un dossier
Tu peux coller ce script PowerShell dans ta console pour convertir tous tes .mkv en .mp4 avec QSV :

Powershell
Get-ChildItem *.mkv | ForEach-Object {
    $input = $_.FullName
    $output = $_.BaseName + ".mp4"
    ffmpeg -hwaccel qsv -c:v h264_qsv -i "$input" -c:v h264_qsv -c:a aac -b:a 192k "$output" //tu peux adapter
}

Script Bash (Linux) 
 convert_mkv_to_mp4.sh
  #!/bin/bash

  for file in *.mkv; do
    output="${file%.mkv}.mp4"
    ffmpeg -hwaccel qsv -c:v h264_qsv -i "$file" -c:v h264_qsv -c:a aac -b:a 192k "$output"
  done


chmod +x convert.sh
./convert_mkv_to_mp4.sh
